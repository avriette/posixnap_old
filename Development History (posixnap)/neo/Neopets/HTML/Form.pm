package Neopets::HTML::Form;

use strict;
use warnings;

use Data::Dumper;

use Exporter;
use Neopets::Debug;
use Neopets::HTML;

# debug flag
our $DEBUG;

=head1 NAME

Neopets::HTML::Form - an HTML form parser

=head1 SYNOPSIS

=head1 ABSTRACT

=head1 METHODS

The following methods are exported:

=over 4

=cut

use vars qw/@ISA @EXPORT $VERSION/;

@ISA = qw/Exporter/;
@EXPORT = qw/get_forms parse_form parse_form_quick/;
$VERSION = 0.01;

=item %form = %{ get_forms({ page => $page }) };

This returns a hashref which represents
the layout of forms on the given $page.

=cut

sub get_forms {
  my ( $args ) = @_;

  my $page = $args -> {page}
    || fatal( "must supply page" );

  my @forms = $page =~ m!<form.*?</form!sig;

  my $pforms = [ ];
  foreach ( 0 .. @forms-1 ) {
    # get action and method
    my ( $action ) = $forms[$_] =~ m/<form[^>]+action='([^']+)/i;
    my ( $method ) = $forms[$_] =~ m/<form[^>]+method='([^']+)/i;
    $pforms -> [$_] -> {action} = $action;
    $pforms -> [$_] -> {method} = $method;

    # get all <input> fields
    my @inputs = $forms[$_] =~ m/<input.*?>/ig;
    foreach my $input ( @inputs ) {
      # get valus
      my ( $name ) = $input =~ m/name='([^']+)/i;
      my ( $type ) = $input =~ m/type='([^']+)/i;
      my ( $value ) = $input =~ m/value='([^']+)/i;

      # cludge it if needed
      if ( $type and $type eq 'radio' ) {
        my @choices = @{ $pforms -> [$_] -> {input} -> {$name} -> {choices} ?
                           $pforms -> [$_] -> {input} -> {$name} -> {choices} :
                           [ ] };
        $value and push @choices, $value;

        $pforms -> [$_] -> {input} -> {$name} -> {type} = $type;
        $pforms -> [$_] -> {input} -> {$name} -> {choices} = \@choices;
        if ( $input =~ m/checked='true'/i ) {
          $pforms -> [$_] -> {input} -> {$name} -> {value} = $value;
        }
      } else {
        $name ? $pforms -> [$_] -> {input} -> {$name} = { type => $type, value => $value } : 1;
      }
    }

    # parse <select>
    my @selects= $forms[$_] =~ m!(<select.*?</select>)!sig;
    foreach my $select ( @selects ) {

      # XXX: i stumbled across some bad html here with unquoted names
      my ( $name ) = $select =~ m/<select[^>]+name=([^>]+)/i;
      $name =~ s/'//g;

      my @options = $select =~ m!(<option.*?>)!sig;
      foreach my $option ( @options ) {
        my ( $value ) = $option =~ m/<option[^>]+value='([^']+)/i;
        my @choices = @{ $pforms -> [$_] -> {input} -> {$name} -> {choices} ?
                           $pforms -> [$_] -> {input} -> {$name} -> {choices} :
                           [ ] };

        $value and push @choices, $value;

        $pforms -> [$_] -> {input} -> {$name} -> {choices} = \@choices;
        if ( $option =~ m/<.*?selected.*?>/i ) {
          $pforms -> [$_] -> {input} -> {$name} -> {value} = $value;
        }
      }

      $pforms -> [$_] -> {input} -> {$name} -> {type} = 'select';
    }

  }

  return $pforms;
}

=item %params = %{ parse_form({ form => \%form }) };

This method generates a param list
acceptable to the Neopets::Agent
object in either get() or post().
It requires a form generated by
the parse() method.

=cut

sub parse_form {
    my ( $args ) = @_;

    my $form = $args -> {form}
        || fatal( 'requires a form to parse' );

    my %params;
    my %inputs = %{ $form -> {input} };
    foreach my $key ( keys %inputs ) {
        $params{$key} = $inputs{$key} -> {value}
            || '' }

    return \%params;
}

=item %params = %{ parse_form_quick( { page => $page } );

This method encorporates the other
methods of this module in one
somple step.  Generates a param list
out of a $page.  This only works when
there is only one form to parse.  If
there is more than one, only the first
is parsed.

Cleans the page using Neopets::HTML.

=cut

sub parse_form_quick {
    my ( $args ) = @_;

    my $page = $args -> {page}
        || fatal( 'requires a page to parse' );

    $page = clean_html( { page => $page } );

    return parse_form(
        { form => ${ get_forms( { page => $page } ) }[0] } );
}

1;

=back

=head1 SUB CLASSES

None.

=head1 COPYRIGHT

Copyright 2002

Neopets::* are the combined works of Alex Avriette and
Matt Harrington.

Matt Harrington <narse@underdogma.net>
Alex Avriette <avriettea@speakeasy.net>

The perl5.5 vs perl < 5.5 build process is stolen with
permission from sungo and the POE team (poe.perl.org),
mostly verbatim.

I suppose we should thank the Neopets people too for
making such a thoroughly enjoyable site. Maybe one day
they will make a text interface for their site so we
wouldnt have to code an API around the LWP:: and 
HTTP:: modules, but probably not. Until then...

=head1 LICENSE

Please see the enclosed LICENSE file for licensing information.

=cut
