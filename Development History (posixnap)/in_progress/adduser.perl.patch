--- adduser.perl	Thu Jan  2 19:30:42 2003
+++ adduser-new.perl	Mon Jan  6 19:48:07 2003
@@ -28,114 +28,131 @@
 #
 # $From: adduser.perl,v 1.22 1996/12/07 21:25:12 ache Exp $
 
+# TODO: pass 'use warnings' and 'use strict'. we're using perl 5.8 now. 
+# this script looks a lot like it did in 1996.
+
 use IPC::Open2;
 use Fcntl qw(:DEFAULT :flock);
 
 ################
 # main
 #
-$test = 0;			# test mode, only for development
-$check_only = 0;
-
-$SIG{'INT'} = 'cleanup';
-$SIG{'QUIT'} = 'cleanup';
-$SIG{'HUP'} = 'cleanup';
-$SIG{'TERM'} = 'cleanup';
-
-&check_root;			# you must be root to run this script!
-&variables;			# initialize variables
-&config_read(@ARGV);		# read variables from config-file
-&parse_arguments(@ARGV);	# parse arguments
+my $test = 0;			# test mode, only for development
+my $check_only = 0;
+my %config;			# switch configs to a hash - tyler
+
+$SIG{'INT'} = \&cleanup;
+$SIG{'QUIT'} = \&cleanup;
+$SIG{'HUP'} = \&cleanup;
+$SIG{'TERM'} = \&cleanup;
+
+die "You are not root!\n" if $< && !$test; 
+
+### set_defaults sets default variables, which read_config supercedes and
+### command line arguments are able to override.
+set_defaults();			# initialize variables
+read_config(@ARGV);		# read variables from config-file
+parse_arguments(@ARGV);	# parse arguments
 
 if (!$check_only &&  $#batch < 0) {
-    &hints;
+    hints();
 }
 
 # check
-$changes = 0;
-&variable_check;		# check for valid variables
-&passwd_check;			# check for valid passwdb
-&shells_read;			# read /etc/shells
-&passwd_read;			# read /etc/master.passwd
-&group_read;			# read /etc/group
-&group_check;			# check for incon*
+my $changes = 0;
+variable_check();		# check for valid variables
+passwd_check();			# check for valid passwdb
+shells_read();			# read /etc/shells
+passwd_read();			# read /etc/master.passwd
+group_read();			# read /etc/group
+group_check();			# check for incon*
 exit 0 if $check_only;		# only check consistence and exit
 
-exit(!&batch(@batch)) if $#batch >= 0; # batch mode
+exit(! batch(@batch)) if $#batch >= 0; # batch mode
 
 # Interactive:
 # main loop for creating new users
-&new_users;	     # add new users
+new_users();	     # add new users
 
 #end
 
 
 # Set adduser "default" variables internally before groking config file
 # Adduser.conf supercedes these
-sub variables {
-    $verbose = 1;		# verbose = [0-2]
-    $defaultpasswd = "yes";	# use password for new users
-    $dotdir = "/etc/skel";	# copy dotfiles from this dir
-    $dotdir_bak = $dotdir;
-    $send_message = "no"; # send message to new user
-    $send_message_bak = '/etc/adduser.message';
-    $config = "/etc/adduser.conf"; # config file for adduser
-    $config_read = 1;		# read config file
-    $logfile = "/var/log/adduser"; # logfile
-    $home = "/home";		# default HOME
-    $etc_shells = "/etc/shells";
-    $etc_passwd = "/etc/master.passwd";
-    $etc_ptmp = "/etc/ptmp";
-    $group = "/etc/group";
-    $pwd_mkdb = "pwd_mkdb -p";	# program for building passwd database
-    $encryptionmethod = "blowfish";
-    $rcsid = '$OpenBSD: adduser.perl,v 1.39 2002/07/10 19:57:31 millert Exp $';
+
+#    I'm temporarily leaving behind the old defines whilst we convert 
+#    to a hash. The problem with this is a really unmanageable set
+#    of configs. And its hard on the eyes - tyler
+
+sub set_defaults {
+	# initialize default %config values
+    $config{verbose} = 1;						# verbosity [0-2]
+    $config{defaultpasswd} = "yes";				# user password for new users
+    $config{dotdir} = "/etc/skel";				# copy default files from here
+    $config{dotdir_bak} = $config{dotdir};		# XXX: but why?
+    $config{send_message} = "no";				# send message to new users?
+    $config{send_message_bak} = '/etc/adduser.message';
+
+    $config{configfile} = "/etc/adduser.conf";	# config file for adduser
+    $config{config_read} = 1;					# read config file
+    $config{logfile} = "/var/log/adduser";		# logfile
+    $config{home} = "/home";					# default location for home directories
+    $config{etc_shells} = "/etc/shells";
+    $config{etc_passwd} = "/etc/master.passwd";
+    $config{etc_ptmp} = "/etc/ptmp";
+    $config{group_file} = "/etc/group";			# XXX: appears unused
+    $config{pwd_mkdb_cmd} = "pwd_mkdb -p";		# program for building passwd database
+    $config{encryptionmethod} = "blowfish";		# one of 'md5', 'des', 'blowfish' or 'old'
+    $config{rcsid} = '$OpenBSD: adduser.perl,v 1.39 2002/07/10 19:57:31 millert Exp $';
 
     # List of directories where shells located
-    @path = ('/bin', '/usr/bin', '/usr/local/bin');
+    $config{path} = [ '/bin', '/usr/bin', '/usr/local/bin' ];
+
     # common shells, first element has higher priority
-    @shellpref = ('csh', 'sh', 'bash', 'tcsh', 'ksh');
+    $config{shellpref} = [ 'csh', 'sh', 'tcsh', 'ksh', 'bash' ];
+
+    $config{encryption_methods} = [ 'blowfish', 'md5', 'des', 'old' ];
 
-    @encryption_methods = ('blowfish', 'md5', 'des', 'old');
+    $config{defaultshell} = 'csh';				# default shell if not empty
+    $config{group_uniq} = 'USER';				# XXX: what on earth is this?
 
-    $defaultshell = 'sh';	# defaultshell if not empty
-    $group_uniq = 'USER';
-    $defaultgroup = $group_uniq;# login groupname, $group_uniq means username
+	# XXX: lose this var.
+    $defaultgroup = $config{group_uniq};		# login groupname, $group_uniq means username
 
-    $uid_start = 1000;		# new users get this uid
-    $uid_end   = 2147483647;	# max. uid
+    $config{uid_start} = 1000;					# new users get this uid
+    $config{uid_end}   = 2147483647;			# max. uid
 
-    # global variables
-    # passwd
-    %username = ();		# $username{username} = uid
-    %uid = ();			# $uid{uid} = username
-    %pwgid = ();		# $pwgid{pwgid} = username; gid from passwd db
+    $config{username} = {};						# convert a username to a uid.
+    $config{uid} = {}; 							# convert a uid to a username.
+	# XXX: what ???
+    $config{pwgid} = {};						# $config{pwgid} -> {pwgid} = username; gid from passwd db
 
-    $password = '';		# password for new users
+	# XXX: i'm guessing this can go away.
+    $config{password} = '';						# password for new users
 
     # group
-    %groupname = ();		# $groupname{groupname} = gid
-    %groupmembers = ();		# $groupmembers{gid} = members of group/kommalist
-    %gid = ();			# $gid{gid} = groupname;    gid form group db
+	$config{groupname} = {};					# convert a groupname to a gid
+	$config{groupmembers} = {};					# convert a gid to a comma delimited string.
+	$config{gid} = {};							# convert a gid to a groupname
 
     # shell
     %shell = ();		# $shell{`basename sh`} = sh
 
     # only for me (=Wolfram)
     if ($test) {
-	$home = "/home/w/tmp/adduser/home";
-	$etc_shells = "./shells";
-	$etc_passwd = "./master.passwd";
-	$group = "./group";
-	$pwd_mkdb = "pwd_mkdb -p -d .";
-	$config = "adduser.conf";
-	$send_message = "./adduser.message";
-	$logfile = "./log.adduser";
+	$config{home} = "/home/w/tmp/adduser/home";
+	$config{etc_shells} = "./shells";
+	$config{etc_passwd} = "./master.passwd";
+	$config{group_file} = "./group";
+	$config{pwd_mkdb_file} = "pwd_mkdb -p -d .";
+	$config{configfile} = "adduser.conf";
+	$config{send_message} = "./adduser.message";
+	$config{logfile} = "./log.adduser";
     }
 
     umask 022;			# don't give login group write access
 
-    $ENV{'PATH'} = "/sbin:/bin:/usr/sbin:/usr/bin";
+    $ENV{PATH} = "/sbin:/bin:/usr/sbin:/usr/bin";
     @passwd_backup = ();
     @group_backup = ();
     @message_buffer = ();
@@ -145,26 +162,28 @@
 
 # read shell database, see also: shells(5)
 sub shells_read {
-    local($sh);
-    local($err) = 0;
-
-    print "Reading $etc_shells\n" if $verbose;
-    open(S, $etc_shells) || die "$etc_shells: $!\n";
+	my ($sh, $err);
 
-    while(<S>) {
-	if (/^\s*\//) {
-	    s/^\s*//; s/\s+.*//; # chop
-	    $sh = $_;
-	    if (-x  $sh) {
-		$shell{&basename($sh)} = $sh;
-	    } else {
-		warn "Shell: $sh not executable!\n";
-		$err++;
-	    }
+	warn "Reading ".$config{etc_shells}."\n" if $config{verbose};
+	open SHELLS, "<".$config{etc_shells}
+		or die $config{etc_shells}.": $!\n";
+
+	while(chomp (my $line = <SHELLS>)) {
+		next if $line =~ /^#/;
+		$line =~ s/\s//g;
+		if (not -e $line) {
+			warn "shell $line does not exist, skipping.\n";
+			++$err;
+			next;
+		}
+		elsif (not -x $line) {
+			warn "shell $line is not executable, skipping.\n";
+			++$err;
+			next;
+		}
+		$shell{ &basename( $line ) } = $line;
 	}
-    }
 
-    push(@list, "/sbin/nologin");
     &shell_pref_add("nologin");
     $shell{"nologin"} = "/sbin/nologin";
 
@@ -175,16 +194,16 @@
 sub shells_add {
     local($sh,$dir,@list);
 
-    return 1 unless $verbose;
+    return 1 unless $config{verbose};
 
-    foreach $sh (@shellpref) {
+    foreach $sh (@{ $config{shellpref} }) {
 	# all known shells
 	if (!$shell{$sh}) {
 	    # shell $sh is not defined as login shell
-	    foreach $dir (@path) {
+	    foreach $dir (@{ $config{path} }) {
 		if (-x "$dir/$sh") {
 		    # found shell
-		    if (&confirm_yn("Found shell: $dir/$sh. Add to $etc_shells?", "yes")) {
+		    if (confirm_yn("Found shell: $dir/$sh. Add to ".$config{etc_shells}."?", "y")) {
 			push(@list, "$dir/$sh");
 			&shell_pref_add("$sh");
 			$shell{&basename("$dir/$sh")} = "$dir/$sh";
@@ -194,7 +213,7 @@
 	    }
 	}
     }
-    &append_file($etc_shells, @list) if $#list >= 0;
+    append_file($config{etc_shells}, @list) if $#list >= 0;
 }
 
 # add shell to preference list without duplication
@@ -202,10 +221,10 @@
     local($new_shell) = @_;
     local($shell);
 
-    foreach $shell (@shellpref) {
+    foreach $shell (@{ $config{shellpref} }) {
 	return if ($shell eq $new_shell);
     }
-    push(@shellpref, $new_shell);
+    push(@{ $config{shellpref} }, $new_shell);
 }
 
 # choose your favourite shell and return the shell
@@ -213,12 +232,12 @@
     local($e,$i,$new_shell);
     local($sh);
 
-    $sh = &shell_default_valid($defaultshell);
-    return $sh unless $verbose;
+    $sh = &shell_default_valid($config{defaultshell});
+    return $sh unless $config{verbose};
 
     $new_shell = &confirm_list("Enter your default shell:", 0,
 		       $sh, sort(keys %shell));
-    print "Your default shell is: $new_shell -> $shell{$new_shell}\n";
+    print "Your default shell is: $new_shell -> ".$shell{$new_shell}."\n";
     $changes++ if $new_shell ne $sh;
     return $new_shell;
 }
@@ -229,7 +248,7 @@
 
     return $sh if $shell{$sh};
 
-    foreach $e (@shellpref) {
+    foreach $e (@{ $config{shellpref} }) {
 	$s = $e;
 	last if defined($shell{$s});
     }
@@ -241,16 +260,17 @@
 # return default home partition (f.e. "/home")
 # create base directory if necessary 
 sub home_partition {
-    local($home) = @_;
-    $home = &stripdir($home);
-    local($h) = $home;
+	my $home = $config{home};
+    my $h = stripdir($home);
 
-    return $h if !$verbose && $h eq &home_partition_valid($h);
+	if (not $config{verbose} and ($h eq home_partition_valid($h))) {
+		return $h;
+	}
 
     while(1) {
-	$h = &confirm_list("Enter your default HOME partition:", 1, $home, "");
-	$h = &stripdir($h);
-	last if $h eq &home_partition_valid($h);
+		$h = confirm_list("Enter your default home partition:", 1, $home, "");
+		$h = stripdir($h);
+		last if $h eq home_partition_valid($h);
     }
 
     $changes++ if $h ne $home;
@@ -285,38 +305,42 @@
 
 # check for valid passwddb
 sub passwd_check {
-    system(split(/\s+/, "$pwd_mkdb -c $etc_passwd"));
-    die "\nInvalid $etc_passwd - cannot add any users!\n" if $?;
+	# XXX: what in the HELL is going on here?
+    system( split(/\s+/, $config{pwd_mkdb_cmd}." -c ".$config{etc_passwd}));
+    die "\nInvalid ".$config{etc_passwd}." - cannot add any users!\n" if $?;
 }
 
 # read /etc/passwd
 sub passwd_read {
     local($p_username, $pw, $p_uid, $p_gid, $sh);
 
-    print "Check $etc_passwd\n" if $verbose;
-    open(P, "$etc_passwd") || die "$etc_passwd: $!\n";
+    warn "Checking ".$config{etc_passwd}."\n" if $config{verbose};
+
+    open P, "<".$config{etc_passwd} 
+		or die $config{etc_passwd}.": $!\n";
 
     # we only use this to lock the password file
-    sysopen(PTMP, $etc_ptmp, O_RDWR|O_CREAT|O_EXCL, 0600) ||
-	die "Password file busy\n";
+    sysopen PTMP, $config{etc_ptmp}, O_RDWR|O_CREAT|O_EXCL, 0600 
+		or die "Password file busy\n";
 
     while(<P>) {
-	chop;
+	chomp;
 	push(@passwd_backup, $_);
 	($p_username, $pw, $p_uid, $p_gid, $sh) = (split(/:/, $_))[0..3,9];
 
-	print "$p_username already exists with uid: $username{$p_username}!\n"
-	    if $username{$p_username} && $verbose;
-	$username{$p_username} = $p_uid;
-	print "User $p_username: uid $p_uid exists twice: $uid{$p_uid}\n"
-	    if $uid{$p_uid} && $verbose && $p_uid;    # don't warn for uid 0
-	print "User $p_username: illegal shell: ``$sh''\n"
-	    if ($verbose && $sh &&
+	if ($config{username} -> {$p_username} and $config{verbose}) {
+		warn "$p_username already exists with uid: ".$config{username} -> {$p_username}."!\n"
+	}
+	$config{username} -> {$p_username} = $p_uid;
+	warn "User $p_username: uid $p_uid exists twice: ".$config{uid} -> {$p_uid}."\n"
+	    if $config{uid} -> {$p_uid} && $config{verbose} && $p_uid;    # don't warn for uid 0
+	warn "User $p_username: illegal shell: ``$sh''\n"
+	    if ($config{verbose} && $sh &&
 		!$shell{&basename($sh)} &&
 		$p_username !~ /^(news|xten|bin|nobody|uucp)$/ &&
 		$sh !~ /\/(pppd|sliplogin)$/);
-	$uid{$p_uid} = $p_username;
-	$pwgid{$p_gid} = $p_username;
+	$config{uid} -> {$p_uid} = $p_username;
+	$config{pwgid} -> {$p_gid} = $p_username;
     }
     close P;
 }
@@ -325,20 +349,20 @@
 sub group_read {
     local($g_groupname,$pw,$g_gid, $memb);
 
-    print "Check $group\n" if $verbose;
+    warn "Checking $group\n" if $config{verbose};
     open(G, "$group") || die "$group: $!\n";
     while(<G>) {
-	chop;
+	chomp;
 	push(@group_backup, $_);
 	($g_groupname, $pw, $g_gid, $memb) = (split(/:/, $_))[0..3];
 
-	$groupmembers{$g_gid} = $memb;
-	warn "Groupname exists twice: $g_groupname:$g_gid ->  $g_groupname:$groupname{$g_groupname}\n"
-	    if $groupname{$g_groupname} && $verbose;
-	$groupname{$g_groupname} = $g_gid;
-	warn "Groupid exists twice:   $g_groupname:$g_gid -> $gid{$g_gid}:$g_gid\n"
-	    if $gid{$g_gid} && $verbose;
-	$gid{$g_gid} = $g_groupname;
+	$config{groupmembers} -> {$g_gid} = $memb;
+	warn "Groupname exists twice: $g_groupname:$g_gid ->  $g_groupname:".$config{groupname} -> {$g_groupname}."\n"
+	    if $config{groupname} -> {$g_groupname} && $config{verbose};
+	$config{groupname} -> {$g_groupname} = $g_gid;
+	warn "Groupid exists twice:   $g_groupname:$g_gid -> ".$config{gid} -> {$g_gid}.":$g_gid\n"
+	    if $config{gid} -> {$g_gid} && $config{verbose};
+	$config{gid} -> {$g_gid} = $g_groupname;
     }
     close G;
 }
@@ -348,10 +372,10 @@
     local($c_gid, $c_username, @list);
 
     foreach $c_gid (keys %pwgid) {
-	if (!$gid{$c_gid}) {
-	    $c_username = $pwgid{$c_gid};
+	if (!$config{gid} -> {$c_gid}) {
+	    $c_username = $config{pwgid} -> {$c_gid};
 	    warn "User ``$c_username'' has gid $c_gid but a group with this " .
-		"gid does not exist.\n" if $verbose;
+		"gid does not exist.\n" if $config{verbose};
 	}
     }
 }
@@ -362,28 +386,34 @@
 
 # return username
 sub new_users_name {
-    local($name);
 
-    while(1) {
-	$name = &confirm_list("Enter username", 1, "a-z0-9_-", "");
-	if (length($name) > 31) {
-	    warn "Username is longer than 31 characters\a\n";
-	    next;
-	}
-	last if (&new_users_name_valid($name) eq $name);
+	# get their initial answer
+	my $name = &confirm_list("Enter username", 1, "a-z0-9_-", "");
+
+	# if they gave us something hokey
+    while( &new_users_name_valid($name) ne $name ) {
+		$name = &confirm_list("Enter username", 1, "a-z0-9_-", "");
+		if (length($name) > 31) {
+	    	warn "Username cannot exceed 31 characters\a\n";
+	    	next;
+		}
     }
     return $name;
 }
 
 sub new_users_name_valid {
-    local($name) = @_;
+    my ($name) = shift;
 
-    if ($name !~ /^[a-z0-9_][a-z0-9_\-]*$/ || $name eq "a-z0-9_-") {
-	warn "Illegal username. " .
-	    "Please use only lowercase characters or digits\a\n";
-	return 0;
-    } elsif ($username{$name}) {
-	warn "Username ``$name'' already exists!\a\n"; return 0;
+	# "a-z0-9_-" is the character class we've given them, they might
+	# enter this on accident (!) so we make sure to not allow it.
+    if ($name !~ /^[a-z0-9_][-a-z0-9_]*$/ or $name eq "a-z0-9_-") {
+		warn "Illegal username. " .
+	    	"Please use only lowercase characters or digits\a\n";
+		return 0;
+    } 
+	elsif ($config{username} -> {$name}) {
+		warn "Username ``$name'' already exists!\a\n"; 
+		return 0;
     }
     return $name;
 }
@@ -414,7 +444,7 @@
 sub new_users_shell {
     local($sh);
 
-    $sh = &confirm_list("Enter shell", 0, $defaultshell, keys %shell);
+    $sh = &confirm_list("Enter shell", 0, $config{defaultshell}, keys %shell);
     return $shell{$sh};
 }
 
@@ -426,9 +456,9 @@
 
     while(1) {
 	$u_id_tmp = &confirm_list("Uid", 1, $u_id, "");
-	last if $u_id_tmp =~ /^[0-9]+$/ && $u_id_tmp <= $uid_end &&
-		! $uid{$u_id_tmp};
-	if ($uid{$u_id_tmp}) {
+	last if $u_id_tmp =~ /^[0-9]+$/ && $u_id_tmp <= $config{uid_end} &&
+		! $config{uid} -> {$u_id_tmp};
+	if ($config{uid} -> {$u_id_tmp}) {
 	    warn "Uid ``$u_id_tmp'' in use!\a\n";
 	} else {
 	    warn "Wrong uid.\a\n";
@@ -437,7 +467,7 @@
     # use calculated uid
     return ($u_id_tmp, $g_id) if $u_id_tmp eq $u_id;
     # recalculate gid
-    $uid_start = $u_id_tmp;
+    $config{uid_start} = $u_id_tmp;
     return &next_id($name);
 }
 
@@ -446,20 +476,20 @@
     local($gid, $name) = @_;
 
     return 0 if
-	$groupmembers{$gid} =~ /^(.*,)?$name(,.*)?$/;
+	$config{groupmembers} -> {$gid} =~ /^(.*,)?$name(,.*)?$/;
 
-    $groupmembers_bak{$gid} = $groupmembers{$gid};
-    $groupmembers{$gid} .= "," if $groupmembers{$gid};
-    $groupmembers{$gid} .= "$name";
+    $groupmembers_bak{$gid} = $config{groupmembers} -> {$gid};
+    $config{groupmembers} -> {$gid} .= "," if $config{groupmembers} -> {$gid};
+    $config{groupmembers} -> {$gid} .= "$name";
 
-    local(@l) = split(',', $groupmembers{$gid});
-    # group(5): A group cannot have more than 200 members. 
+    local(@l) = split(',', $config{groupmembers} -> {$gid});
     # The maximum line length of /etc/group is 1024 characters. 
-    # Longer lines will be skiped.
-    if ($#l >= 200 || 
-	length($groupmembers{$gid}) > 1024 - 50) { # 50 is for group name
-	warn "WARNING, group line ``$gid{$gid}'' is either too long or has\n" .
-	    "too many users in the group, see group(5)\a\n";
+    # Longer lines will be skiped. This is a restriction of some 
+    # YP environments. We add 50 characters here for the groupname 
+    # to be safe
+    if (length $config{groupmembers} -> {$gid} > 1024 - 50) {
+	warn "WARNING, group lines cannot exceed 1024 characters. Skipping\n".
+	$config{groupmembers} -> {$gid}."\a\n";
     }
     return $name;
 }
@@ -471,7 +501,7 @@
     local($group_login, $group);
 
     $group = $name;
-    $group = $defaultgroup if $defaultgroup ne $group_uniq;
+    $group = $defaultgroup if $defaultgroup ne $config{group_uniq};
 
     if ($new_users_ok) {
 	# clean up backup
@@ -479,7 +509,7 @@
     } else {
 	# restore old groupmembers, user was not accept
 	foreach $e (keys %groupmembers_bak) {
-	    $groupmembers{$e} = $groupmembers_bak{$e};
+	    $config{groupmembers} -> {$e} = $groupmembers_bak{$e};
 	}
     }
 
@@ -488,24 +518,20 @@
 				     ($name, $group));
 	last if $group_login eq $group;
 	last if $group_login eq $name;
-	last if defined $groupname{$group_login};
-	if ($group_login eq $group_uniq) {
+	last if defined $config{groupname} -> {$group_login};
+	if ($group_login eq $config{group_uniq}) {
 	    $group_login = $name; last;
 	}
 
-	if (defined $gid{$group_login}) {
+	if (defined $config{gid} -> {$group_login}) {
 	    # convert numeric groupname (gid) to groupname
-	    $group_login = $gid{$group_login};
+	    $group_login = $config{gid} -> {$group_login};
 	    last;
 	}
 	warn "Group does not exist!\a\n";
     }
 
-    #if (defined($groupname{$group_login})) {
-    #	&add_group($groupname{$group_login}, $name);
-    #}
-
-    return ($group_login, $group_uniq) if $group_login eq $name;
+    return ($group_login, $config{group_uniq}) if $group_login eq $name;
     return ($group_login, $group_login);
 }
 
@@ -515,19 +541,15 @@
     local($group_login, $group);
 
     $group_login = $name;
-    $group_login = $defaultgroup if $defaultgroup ne $group_uniq;
+    $group_login = $defaultgroup if $defaultgroup ne $config{group_uniq};
 
-    if (defined $gid{$group_login}) {
+    if (defined $config{gid} -> {$group_login}) {
 	# convert numeric groupname (gid) to groupname
-	$group_login = $gid{$group_login};
+	$group_login = $config{gid} -> {$group_login};
     }
 
-    # if (defined($groupname{$group_login})) {
-    #	&add_group($groupname{$group_login}, $name);
-    # }
-
     return $group_login
-	if defined($groupname{$group_login}) || $group_login eq $name;
+	if defined($config{groupname} -> {$group_login}) || $group_login eq $name;
     warn "Group ``$group_login'' does not exist\a\n";
     return 0;
 }
@@ -562,14 +584,14 @@
 
     foreach $e (split(/[,\s]+/, $groups)) {
 	# convert numbers to groupname
-	if ($e =~ /^[0-9]+$/ && $gid{$e}) {
-	    $e = $gid{$e};
+	if ($e =~ /^[0-9]+$/ && $config{gid} -> {$e}) {
+	    $e = $config{gid} -> {$e};
 	}
-	if (defined($groupname{$e})) {
+	if (defined($config{groupname} -> {$e})) {
 	    if ($e eq $group_login) {
 		# do not add user to a group if this group
 		# is also the login group.
-	    } elsif (&add_group($groupname{$e}, $name)) {
+	    } elsif (add_group($config{groupname} -> {$e}, $name)) {
 		$new_groups .= "$e ";
 	    } else {
 		warn "$name is already member of group ``$e''\n";
@@ -584,7 +606,7 @@
 # your last change
 sub new_users_ok {
 
-    print <<EOF;
+    print <<"EOF";
 
 Name:	  $name
 Password: ****
@@ -592,11 +614,11 @@
 Uid:	  $u_id
 Gid:	  $g_id ($group_login)
 Groups:	  $group_login $new_groups
-HOME:	  $home/$name
+HOME:	  $config{home}/$name
 Shell:	  $sh
 EOF
 
-    return &confirm_yn("OK?", "yes");
+    return &confirm_yn("OK?", "y");
 }
 
 # make password database
@@ -605,10 +627,11 @@
     local($user);
 
     $user = (split(/:/, $last))[0];
-    system(split(/\s+/, "$pwd_mkdb  -u $user $etc_passwd"));
+	# XXX: WHAT IN THE HELL IS GOING ON HERE??
+    system(split(/\s+/, $config{pwd_mkdb_cmd}."  -u $user ".$config{etc_passwd}));
     if ($?) {
 	warn "$last\n";
-	warn "``$pwd_mkdb'' failed\n";
+	warn "``".$config{pwd_mkdb}."'' failed\n";
 	exit($? >> 8);
     }
 }
@@ -618,26 +641,25 @@
     local($e, @a);
 
     # Add *new* group
-    if (!defined($groupname{$group_login}) && !defined($gid{$g_id})) {
+    if (!defined($config{groupname} -> {$group_login}) && !defined($config{gid} -> {$g_id})) {
 	push(@group_backup, "$group_login:*:$g_id:");
-	$groupname{$group_login} = $g_id;
-	$gid{$g_id} = $group_login;
-	# $groupmembers{$g_id} = $group_login;
+	$config{groupname} -> {$group_login} = $g_id;
+	$config{gid} -> {$g_id} = $group_login;
+	# $config{groupmembers} -> {$g_id} = $group_login;
     }
 
-    if ($new_groups || defined($groupname{$group_login}) ||
-	defined($gid{$groupname{$group_login}}) &&
-		$gid{$groupname{$group_login}} ne "+") {
+    if ($new_groups || defined($config{groupname} -> {$group_login}) ||
+	defined($config{gid} -> {$config{groupname} -> {$group_login}}) &&
+		$config{gid} -> {$config{groupname} -> {$group_login}} ne "+") {
 	# new user is member of some groups
 	# new login group is already in name space
 	rename($group, "$group.bak");
-	#warn "$group_login $groupname{$group_login} $groupmembers{$groupname{$group_login}}\n";
 	foreach $e (sort {$a <=> $b} (keys %gid)) {
-	    push(@a, "$gid{$e}:*:$e:$groupmembers{$e}");
+	    push(@a, $config{gid} -> {$e}.":*:$e:".$config{groupmembers} -> {$e});
 	}
-	&append_file($group, @a);
+	append_file($group, @a);
     } else {
-	&append_file($group, "$group_login:*:$g_id:");
+	append_file($group, $group_login.":*:".$g_id.":");
     }
 
 }
@@ -645,42 +667,44 @@
 sub new_users_passwd_update {
     # update passwd/group variables
     push(@passwd_backup, $new_entry);
-    $username{$name} = $u_id;
-    $uid{$u_id} = $name;
-    $pwgid{$g_id} = $name;
+    $config{username} -> {$name} = $u_id;
+    $config{uid} -> {$u_id} = $name;
+    $config{pwgid} -> {$g_id} = $name;
 }
 
-# send message to new user
+# optionally send message to the new user
 sub new_users_sendmessage {
-    return 1 if $send_message eq "no";
+    return 1 if $config{send_message} eq "no";
 
-    local($cc) =
+    my ($cc) =
 	&confirm_list("Send message to ``$name'' and:",
 		      1, "no", ("root", "second_mail_address", 
 		      "no carbon copy"));
-    local($e);
-    $cc = "" if $cc eq "no";
+	$cc = $cc eq "no" ? "" : $cc;
 
-    @message_buffer = ();
-    message_read ($send_message);
+	# $config{send_message} here is set by message_default() in batch()
+    my @message_buffer = message_read ($config{send_message});
 
-    foreach $e (@message_buffer) {
-	print eval "\"$e\"";
+    foreach my $e (@message_buffer) {
+		# XXX: this is hideously unsafe. fix with Safe.pm
+		print eval "\"$e\"";
     }
     print "\n";
 
-    local(@message_buffer_append) = ();
-    if (!&confirm_yn("Add anything to default message", "no")) {
-	print "Use ``.'' or ^D alone on a line to finish your message.\n";
-	push(@message_buffer_append, "\n");
-	while($read = <STDIN>) {
-	    last if $read eq "\.\n";
-	    push(@message_buffer_append, $read);
-	}
+    if (!&confirm_yn("Add anything to default message?", "n")) {
+		print "Use ``.'' or ^D alone on a line to finish your message.\n";
+    	my @message_buffer_append;
+		while(chomp (my $read = <STDIN>)) {
+			last if $read eq '.';
+			push @message_buffer_append, $read."\n";
+		}
     }
+	# add a blank line to the top
+	unshift @message_buffer_append, "\n";
 
-    &sendmessage("$name $cc", (@message_buffer, @message_buffer_append))
-	if (&confirm_yn("Send message", "yes"));
+	if (&confirm_yn("Send messaage?", "y")) {
+    	&sendmessage("$name $cc", (@message_buffer, @message_buffer_append))
+	}
 }
 
 sub sendmessage {
@@ -702,13 +726,13 @@
 sub new_users_password {
 
     # empty password
-    return "" if $defaultpasswd ne "yes";
+    return "" if $config{defaultpasswd} ne "yes";
 
-    local($password);
+    my $password;
 
     while(1) {
 	system("stty", "-echo");
-	$password = &confirm_list("Enter password", 1, "", "");
+	$password = confirm_list("Enter password", 1, "", "");
 	system("stty", "echo");
 	print "\n";
 	if ($password ne "") {
@@ -719,7 +743,7 @@
 	    last if $password eq $newpass;
 	    print "They didn't match, please try again\n";
 	}
-	elsif (!&confirm_yn("Set the password so that user cannot logon?", "no")) {
+	elsif (!&confirm_yn("Set the password so that user cannot logon?", "n")) {
 	    last;
 	}
     }
@@ -730,10 +754,10 @@
 
 sub new_users {
 
-    print "\n" if $verbose;
+    print "\n" if $config{verbose};
     print "Ok, let's go.\n" .
 	  "Don't worry about mistakes. I will give you the chance later to " .
-	  "correct any input.\n" if $verbose;
+	  "correct any input.\n" if $config{verbose};
 
     # name: Username
     # fullname: Full name
@@ -747,7 +771,7 @@
     local($new_users_ok) = 1;
 
 
-    $new_groups = "no" unless $groupname{$new_groups};
+    $new_groups = "no" unless $config{groupname} -> {$new_groups};
 
     while(1) {
 	$name = &new_users_name;
@@ -757,22 +781,22 @@
 	($group_login, $defaultgroup) =
 	    &new_users_grplogin($name, $defaultgroup, $new_users_ok);
 	# do not use uniq username and login group
-	$g_id = $groupname{$group_login} if (defined($groupname{$group_login}));
+	$g_id = $config{groupname} -> {$group_login} if (defined($config{groupname} -> {$group_login}));
 
 	$new_groups = &new_users_groups($name, $new_groups);
-	$password = &new_users_password;
+	$config{password} = new_users_password();
 
 
 	if (&new_users_ok) {
 	    $new_users_ok = 1;
 
 	    $cryptpwd = "*";	# Locked by default
-	    $cryptpwd = encrypt($password, &salt) if ($password ne "");
+	    $cryptpwd = encrypt($config{password}, salt()) if length $config{password};
 
 	    # obscure perl bug
 	    $new_entry = "$name\:" . "$cryptpwd" .
-		"\:$u_id\:$g_id\::0:0:$fullname:$home/$name:$sh";
-	    &append_file($etc_passwd, "$new_entry");
+		"\:$u_id\:$g_id\::0:0:$fullname:".$config{home}."/$name:$sh";
+	    &append_file($config{etc_passwd}, $new_entry);
 	    &new_users_pwdmkdb("$new_entry");
 	    &new_users_group_update;
 	    &new_users_passwd_update;  print "Added user ``$name''\n";
@@ -782,29 +806,29 @@
 	} else {
 	    $new_users_ok = 0;
 	}
-	if (!&confirm_yn("Add another user?", "yes")) {
-	    print "Goodbye!\n" if $verbose;
+	if (!&confirm_yn("Add another user?", "y")) {
+	    print "Goodbye!\n" if $config{verbose};
 	    last;
 	}
-	print "\n" if !$verbose;
+	print "\n" if !$config{verbose};
     }
 }
 
 sub batch {
-    local($name, $groups, $fullname, $password) = @_;
-    local($sh);
+	my ($name, $groups, $fullname, $password) = @_;
+    my ($sh);
 
-    $defaultshell = &shell_default_valid($defaultshell);
-    return 0 unless $home = &home_partition_valid($home);
-    return 0 if $dotdir ne &dotdir_default_valid($dotdir);
-    $send_message = &message_default;
+    $config{defaultshell} = shell_default_valid($config{defaultshell});
+    return 0 unless $config{home} = &home_partition_valid($config{home});
+    return 0 if $config{dotdir} ne &dotdir_default_valid($config{dotdir});
+    $config{send_message} = &message_default;
 
-    return 0 if $name ne &new_users_name_valid($name);
-    $sh = $shell{$defaultshell};
+    return 0 if $name ne new_users_name_valid($name);
+    $sh = $shell{$config{defaultshell}};
     ($u_id, $g_id) = &next_id($name);
     $group_login = &new_users_grplogin_batch($name, $defaultgroup);
     return 0 unless $group_login;
-    $g_id = $groupname{$group_login} if (defined($groupname{$group_login}));
+    $g_id = $config{groupname} -> {$group_login} if (defined($config{groupname} -> {$group_login}));
     ($flag, $new_groups) = &new_users_groups_valid($groups);
     return 0 if $flag;
 
@@ -815,35 +839,44 @@
     }
     # obscure perl bug
     $new_entry = "$name\:" . "$cryptpwd" .
-	"\:$u_id\:$g_id\::0:0:$fullname:$home/$name:$sh";
-    &append_file($etc_passwd, "$new_entry");
-    &new_users_pwdmkdb("$new_entry");
-    &new_users_group_update;
-    &new_users_passwd_update;  print "Added user ``$name''\n";
-    &sendmessage($name, @message_buffer) if $send_message ne "no";
-    &adduser_log("$name:*:$u_id:$g_id($group_login):$fullname");
-    &home_create($name, $group_login);
+	"\:$u_id\:$g_id\::0:0:$fullname:".$config{home}."/$name:$sh";
+    append_file($config{etc_passwd}, $new_entry);
+    new_users_pwdmkdb($new_entry);
+    new_users_group_update;
+    new_users_passwd_update;  print "Added user ``$name''\n";
+    sendmessage($name, @message_buffer) if $config{send_message} ne "no";
+    adduser_log("$name:*:$u_id:$g_id($group_login):$fullname");
+    home_create($name, $group_login);
 }
 
-# ask for password usage
+# ask for password usage (if we're verbose)
 sub password_default {
-    local($p) = $defaultpasswd;
-    if ($verbose) {
-	$p = &confirm_yn("Prompt for passwords by default", $defaultpasswd);
-	$changes++ unless $p;
-    }
-    return "yes" if (($defaultpasswd eq "yes" && $p) ||
-		     ($defaultpasswd eq "no" && !$p));
+	my $p;
+    if ($config{verbose}) {
+		$p = &confirm_yn("Prompt for passwords by default", 
+			$config{defaultpasswd} eq "yes" ? "y" : "n" 
+		);
+		# confirm_yn() is going to return TRUE if the user agrees. 
+		# if this is false, the user has made changes.
+		$changes++ unless $p;
+    }
+	# we need to return the opposite of defaultpasswd here if the user
+	# disagreed.
+    return "yes" if (($config{defaultpasswd} eq "yes" && $p) ||
+		     ($config{defaultpasswd} eq "no" && !$p));
     return "no";    # otherwise
 }
 
 # get default encryption method
 sub encryption_default {
     local($m) = "";
-    if ($verbose) {
-	while (&encryption_check($m) == 0) {
-            $m = &confirm_list("Default encryption method for passwords:", 1,
-                              $encryption_methods[0], @encryption_methods);
+    if ($config{verbose}) {
+	while (encryption_check($m) == 0) {
+            $m = confirm_list(
+				"Default encryption method for passwords:", 1,
+				@{ $config{encryption_methods} }[0],
+				@{ $config{encryption_methods} },
+			);
 	}
     }
     return($m);
@@ -853,7 +886,7 @@
 sub encryption_check {
     local($m) = $_[0];
 
-    foreach $i (@encryption_methods) {
+    foreach $i (@{ $config{encryption_methods} }) {
         if ($m eq $i) { return 1; }
     }
     
@@ -863,7 +896,6 @@
 
 # misc
 sub check_root {
-    die "You are not root!\n" if $< && !$test;
 }
 
 sub usage {
@@ -886,52 +918,43 @@
     [-unencrypted]
     [-v|-verbose]
 
-home=$home shell=$defaultshell dotdir=$dotdir login_group=$defaultgroup
-message_file=$send_message uid_start=$uid_start uid_end=$uid_end
+home=$config{home} shell=$config{defaultshell} dotdir=$config{dotdir} login_group=$defaultgroup
+message_file=$config{send_message} uid_start=$config{uid_start} uid_end=$uid_end
 USAGE
     exit 1;
 }
 
-# uniq(1)
-sub uniq {
-    local(@list) = @_;
-    local($e, $last = "", @array);
-
-    foreach $e (sort @list) {
-	push(@array, $e) unless $e eq $last;
-	$last = $e;
-    }
-    return @array;
-}
-
 # Generate an appropriate argument to encrypt()
 # That may be a DES salt or a blowfish rotation count
 sub salt {
     local($salt);		# initialization
-    if ($encryptionmethod eq "des" || $encryptionmethod eq "old") {
+    if ($config{encryptionmethod} eq "des" or 
+		$config{encryptionmethod} eq "old") {
         local($i, $rand);
         local(@itoa64) = ( '0' .. '9', 'a' .. 'z', 'A' .. 'Z' ); # 0 .. 63
 
-        warn "calculate salt\n" if $verbose > 1;
+        warn "calculate salt\n" if $config{verbose} > 1;
 
         for ($i = 0; $i < 8; $i++) {
 	    srand(time + $rand + $$); 
 	    $rand = rand(25*29*17 + $rand);
 	    $salt .=  $itoa64[$rand & $#itoa64];
         }
-    } elsif ($encryptionmethod eq "md5") {
+    } elsif ($config{encryptionmethod} eq "md5") {
         $salt = "";
-    } elsif ($encryptionmethod =~ /^blowfish/ ) {
-        ($encryptionmethod, $salt) = split(/\,/, $encryptionmethod);
+    } elsif ($config{encryptionmethod} =~ /^blowfish/ ) {
+        ($config{encryptionmethod}, $salt) = split(/,/, $config{encryptionmethod});
 	if ($salt eq "") { $salt = 7; }	# default rounds inf unspecified
     } else {
-        warn "$encryptionmethod encryption method invalid\n" if ($verbose > 0);
-	warn "Falling back to blowfish,7...\n" if ($verbose > 0);
-	$encryptionmethod = "blowfish";
+		if ($config{verbose}) {
+        	warn $config{encryptionmethod}." encryption method invalid\n";
+			warn "Falling back to blowfish,7...\n";
+		}
+	$config{encryptionmethod} = "blowfish";
 	$salt = 7;
     }
         
-    warn "Salt is: $salt\n" if $verbose > 1;
+    warn "Salt is: $salt\n" if $config{verbose} > 1;
 
     return $salt;
 }
@@ -941,16 +964,17 @@
     local($pass, $salt) = ($_[0], $_[1]);
     local($args, $crypt);
 
-    if ($encryptionmethod eq "des" || $encryptionmethod eq "old") {
+    if ($config{encryptionmethod} eq "des" or
+		$config{encryptionmethod} eq "old") {
         $args = "-s $salt";
-    } elsif ($encryptionmethod eq "md5") {
+    } elsif ($config{encryptionmethod} eq "md5") {
         $args = "-m";
-    } elsif ($encryptionmethod eq "blowfish") {
+    } elsif ($config{encryptionmethod} eq "blowfish") {
         $args = "-b $salt";
     }
 
     open2(\*ENCRD, \*ENCWR, "/usr/bin/encrypt $args");
-    print ENCWR "$pass\n";
+    print ENCWR $pass."\n";
     close ENCWR;
     $crypt = <ENCRD>;
     close ENCRD;
@@ -961,42 +985,43 @@
 
 # hints
 sub hints {
-    if ($verbose) {
+    if ($config{verbose}) {
 	print "Use option ``-silent'' if you don't want to see " .
 	      "all warnings and questions.\n\n";
     }
 }
 
 #
+# XXX: fucking fix this already
 sub parse_arguments {
     local(@argv) = @_;
 
     while ($_ = $argv[0], /^-/) {
 	shift @argv;
 	last if /^--$/;
-	if    (/^--?(v|verbose)$/)	{ $verbose = 1 }
-	elsif (/^--?(s|silent|q|quiet)$/)  { $verbose = 0 }
-	elsif (/^--?(debug)$/)	    { $verbose = 2 }
+	if    (/^--?(v|verbose)$/)	{ $config{verbose} = 1 }
+	elsif (/^--?(s|silent|q|quiet)$/)  { $config{verbose} = 0 }
+	elsif (/^--?(debug)$/)	    { $config{verbose} = 2 }
 	elsif (/^--?(h|help|\?)$/)	{ &usage }
-	elsif (/^--?(home)$/)	 { $home = $argv[0]; shift @argv }
-	elsif (/^--?(shell)$/)	 { $defaultshell = $argv[0]; shift @argv }
-	elsif (/^--?(dotdir)$/)	 { $dotdir = $argv[0]; shift @argv }
-	elsif (/^--?(uid_start)$/)	 { $uid_start = $argv[0]; shift @argv }
+	elsif (/^--?(home)$/)	 { $config{home} = $argv[0]; shift @argv }
+	elsif (/^--?(shell)$/)	 { $config{defaultshell} = $argv[0]; shift @argv }
+	elsif (/^--?(dotdir)$/)	 { $config{dotdir} = $argv[0]; shift @argv }
+	elsif (/^--?(uid_start)$/)	 { $config{uid_start} = $argv[0]; shift @argv }
 	elsif (/^--?(uid_end)$/)	 { $uid_end = $argv[0]; shift @argv }
 	elsif (/^--?(group)$/)	 { $defaultgroup = $argv[0]; shift @argv }
 	elsif (/^--?(check_only)$/) { $check_only = 1 }
-	elsif (/^--?(message)$/) { $send_message = $argv[0]; shift @argv;
+	elsif (/^--?(message)$/) { $config{send_message} = $argv[0]; shift @argv;
 				   $sendmessage = 1; }
 	elsif (/^--?(unencrypted)$/)	{ $unencrypted = 1 }
 	elsif (/^--?(batch)$/)	 {
-	    @batch = splice(@argv, 0, 4); $verbose = 0;
+	    @batch = splice(@argv, 0, 4); $config{verbose} = 0;
 	    die "batch: too few arguments\n" if $#batch < 0;
 	}
 	# see &config_read
 	elsif (/^--?(config_create)$/)	{ &hints; &create_conf; exit(0); }
-	elsif (/^--?(noconfig)$/)	{ $config_read = 0; }
+	elsif (/^--?(noconfig)$/)	{ $config{config_read} = 0; }
 	elsif (/^--?(e|encryption)$/) {
-	    $encryptionmethod = $argv[0];
+	    $config{encryptionmethod} = $argv[0];
 	    shift @argv;
 	}
 	else			    { &usage }
@@ -1021,14 +1046,14 @@
 
 # return 1 if $file is a readable file or link
 sub filetest {
-    local($file, $verbose) = @_;
+    local($file, $config{verbose}) = @_;
 
     if (-e $file) {
 	if (-f $file || -l $file) {
 	    return 1 if -r _;
-	    warn "$file unreadable\n" if $verbose;
+	    warn "$file unreadable\n" if $config{verbose};
 	} else {
-	    warn "$file is not a plain file or link\n" if $verbose;
+	    warn "$file is not a plain file or link\n" if $config{verbose};
 	}
     }
     return 0;
@@ -1040,27 +1065,27 @@
 
     &shells_read;			# Pull in /etc/shells info
     &shells_add;			# maybe add some new shells
-    $defaultshell = &shell_default;	# enter default shell
-    $home = &home_partition($home);	# find HOME partition
-    $dotdir = &dotdir_default;		# check $dotdir
-    $send_message = &message_default;   # send message to new user
-    $defaultpasswd = &password_default; # maybe use password
-    $defaultencryption = &encryption_default;	# Encryption method
+    $config{defaultshell} = shell_default();	# enter default shell
+    $config{home} = home_partition($config{home});	# find HOME partition
+    $config{dotdir} = dotdir_default();		# check $config{dotdir}
+    $config{send_message} = message_default();   # send message to new user
+    $config{defaultpasswd} = password_default(); # maybe use password
+    $defaultencryption = encryption_default();	# Encryption method
 
-    if ($send_message ne 'no') {
-	&message_create($send_message);
+    if ($config{send_message} ne 'no') {
+	&message_create($config{send_message});
     } else {
-	&message_create($send_message_bak);
+	&message_create($config{send_message_bak});
     }
     &config_write(1);
 }
 
 # log for new user in /var/log/adduser
 sub adduser_log {
-    local($string) = @_;
-    local($e);
+    my ($string) = @_;
+    my $e;
 
-    return 1 if $logfile eq "no";
+    return 1 if $config{logfile} eq "no";
 
     local($sec, $min, $hour, $mday, $mon, $year) = localtime;
     $year += 1900;
@@ -1071,31 +1096,36 @@
 	eval "\$$e = 0 . \$$e" if (eval "\$$e" < 10);
     }
 
-    &append_file($logfile, "$year/$mon/$mday $hour:$min:$sec $string");
+    &append_file($config{logfile}, "$year/$mon/$mday $hour:$min:$sec $string");
 }
 
-# create HOME directory, copy dotfiles from $dotdir to $HOME
+# create home directory, copy dotfiles from $config{dotdir} to $config{home}
 sub home_create {
-    local($name, $group) = @_;
-    local($homedir) = "$home/$name";
+    my ($name, $group) = @_;
+    my $homedir = $config{home}."/".$name;
 
     if (-e "$homedir") {
-	warn "HOME Directory ``$homedir'' already exists\a\n";
+	warn "Home directory ``$homedir'' already exists\a\n";
 	return 0;
     }
 
-    if ($dotdir eq 'no') {
-	if (!mkdir("$homedir",0755)) {
-	    warn "mkdir $homedir: $!\n"; return 0;
-	}
-	system 'chown', "$name:$group", $homedir;
-	return !$?;
+    if ($config{dotdir} eq 'no') {
+		if (not mkdir $homedir, 0755 ) {
+			warn "mkdir $homedir: $!\n"; return 0;
+		}
+		# XXX: need to get this uid from the $name and $group above.
+		chown $uid, $gid, $homedir;
+
+		# XXX: clarify
+		return !$?;
     }
 
-    # copy files from  $dotdir to $homedir
+    # copy files from  $config{dotdir} to $homedir
     # rename 'dot.foo' files to '.foo'
-    print "Copy files from $dotdir to $homedir\n" if $verbose;
-    system("cp", "-R", $dotdir, $homedir);
+    print "Copy files from ".$config{dotdir}." to $homedir\n" if $config{verbose};
+
+	# XXX: this is FUCKED.
+    system("cp", "-R", $config{dotdir}, $homedir);
     system("chmod", "-R", "u+wrX,go-w", $homedir);
     system("chown", "-R", "$name:$group", $homedir);
 
@@ -1136,21 +1166,21 @@
 
 
 	if (-d $d) {
-	    warn "Oops, $d already exists\n" if $verbose;
+	    warn "Oops, $d already exists\n" if $config{verbose};
 	} else {
-	    print "Create $d\n" if $verbose;
+	    print "Create $d\n" if $config{verbose};
 	    if (!mkdir("$d", 0755)) {
 		warn "$d: $!\a\n"; return 0;
 	    }
 	}
 
 	unlink($dir);		# symlink to nonexist file
-	print "Create symlink: $dir -> $d\n" if $verbose;
+	print "Create symlink: $dir -> $d\n" if $config{verbose};
 	if (!symlink("$d", $dir)) {
 	    warn "Symlink $d: $!\a\n"; return 0;
 	}
     } else {
-	print "Create $dir\n" if $verbose;
+	print "Create $dir\n" if $config{verbose};
 	if (!mkdir("$dir", 0755)) {
 	    warn "Directory ``$dir'': $!\a\n"; return 0;
 	}
@@ -1168,7 +1198,7 @@
 	$dir = "$p/$d";
 	$dir =~ s|^//|/|;
 	if (! -e "$dir") {
-	    print "Create $dir\n" if $verbose;
+	    print "Create $dir\n" if $config{verbose};
 	    if (!mkdir("$dir", 0755)) {
 		warn "$dir: $!\n"; return 0;
 	    }
@@ -1192,78 +1222,104 @@
 # Read one of the elements from @list. $confirm is default.
 # If !$allow accept only elements from @list.
 sub confirm_list {
-    local($message, $allow, $confirm, @list) = @_;
-    local($read, $c, $print);
+    my ($message, $allow, $confirm, @list) = @_;
 
-    $print = "$message" if $message;
-    $print .= " " unless $message =~ /\n$/ || $#list == 0;
+	# this is the variable we'll use to display to the user
+    my $print = $message ? $message : "";
 
-    $print .= join($", &uniq(@list)); #"
-    $print .= " " unless $message =~ /\n$/ && $#list == 0;
-    print "$print";
-    print "\n" if (length($print) + length($confirm)) > 60;
+	# add a space unless $message ends in a newline or @list is empty.
+	if (($message =~ /\n$/s) or ($list == ())) {
+		$print .= " ";
+	}
+    
+    # grab the unique values of @list
+	# XXX: this really seems unnecessary.
+	my %u = map { $_ => 1 } @list; 
+    $print .= join ' ', keys %u;
+		
+	# display the list for the user
+    print $print." ";
+
+	# add a newline if the list winds up being longish
+	if ((length $print + length $confirm) > 60) {
+		print "\n";
+	}
     print "[$confirm]: ";
 
-    chop($read = <STDIN>);
-    $read =~ s/^\s*//;
-    $read =~ s/\s*$//;
-    return $confirm if $read eq "";
-    return "$read" if $allow;
-
-    foreach $c (@list) {
-	return $read if $c eq $read;
-    }
-    warn "$read: is not allowed!\a\n";
-    return &confirm_list($message, $allow, $confirm, @list);
-}
-
-# YES or NO question
-# return 1 if &confirm("message", "yes") and answer is yes
-#	or if &confirm("message", "no") an answer is no
-# otherwise 0
+    while (chomp (my $read = <STDIN>)) {
+		# zap leading and trailing space.
+		my ($answer) = $read =~ /^\s*?([\S\s]+)\s*?/;
+
+		# they just hit enter. return.
+		return $confirm unless length $read;
+
+		# this was free-form, so return their -original- answer.
+    	return $read if $allow;
+
+		# they picked a selection from the list, return it
+		return $answer if grep { $answer } @list;
+
+		# they goofed. let them know
+    	warn "\"$answer\" is not an acceptable parameter.!\a\n";
+
+		# prompt again.
+		print "[$confirm]: ";
+	}
+}
+
+# prompt the user for "yes" or "no" returns true if users answer
+# matches requested default, false if not.
 sub confirm_yn {
-    local($message, $confirm) = @_;
-    local($yes) = '^(yes|YES|y|Y)$';
-    local($no) = '^(no|NO|n|N)$';
-    local($read, $c);
+    my ($message, $confirm) = @_;
+    my ($yes) = qr{\s*?(?:yes|y|1)\s*?}i;
+    my ($no)  = qr{\s*?(?:no|n|0)\s*?}i;
+	my $default;
+
+    if ($confirm =~ $yes) {
+		$default = "Yn";
+    } 
+	elsif ($confirm =~ $no) {
+		$default = "yN";
+    }
+    print "$message [$default]: ";
+    while (chomp (my $read = <STDIN>)) {
+		my ($answer) = $read =~ /($yes|$no)/i;
+        if (not length $read or not length $answer) {
+	        # user just hit enter.
+		    return 1;
+	    }
 
-    if ($confirm && ($confirm =~ "$yes" || $confirm == 1)) {
-	$confirm = "y";
-    } else {
-	$confirm = "n";
-    }
-    print "$message (y/n) [$confirm]: ";
-    chop($read = <STDIN>);
-    $read =~ s/^\s*//;
-    $read =~ s/\s*$//;
-    return 1 unless $read;
-
-    if (($confirm eq "y" && $read =~ "$yes") ||
-	($confirm eq "n" && $read =~ "$no")) {
-	return 1;
-    }
-
-    if ($read !~ "$yes" && $read !~ "$no") {
-	warn "Wrong value. Enter again!\a\n";
-	return &confirm_yn($message, $confirm);
-    }
-    return 0;
+		# return true if we met our default condition
+		return $answer if ($confirm =~ $yes and $answer =~ $yes);
+		return $answer if ($confirm =~ $no and $answer =~ $no);
+
+		# user gave us a valid answer that disagreed with our default
+		if ($answer =~ $yes or $answer =~ $no) {
+			return 0;
+		}
+
+        warn "Please enter 'yes' or 'no'.\a\n";
+		print "[$default]: ";
+		next; 
+	}
+    return 0; # we should never get here.
 }
 
-# test if $dotdir exist
-# return "no" if $dotdir not exist or dotfiles should not copied
+# test if $config{dotdir} exist
+# return "no" if $config{dotdir} not exist or dotfiles should not copied
 sub dotdir_default {
-    local($dir) = $dotdir;
+    local($dir) = $config{dotdir};
 
-    return &dotdir_default_valid($dir) unless $verbose;
-    while($verbose) {
+    return &dotdir_default_valid($dir) unless $config{verbose};
+    while($config{verbose}) {
+	# XXX: this is unclear
 	$dir = &confirm_list("Copy dotfiles from:", 1,
-	    $dir, ("no", $dotdir_bak, $dir));
+	    $dir, ("no", $config{dotdir_bak}, $dir));
 	last if $dir eq &dotdir_default_valid($dir);
     }
-    warn "Do not copy dotfiles.\n" if $verbose && $dir eq "no";
+    warn "Do not copy dotfiles.\n" if $config{verbose} && $dir eq "no";
 
-    $changes++ if $dir ne $dotdir;
+    $changes++ if $dir ne $config{dotdir};
     return $dir;
 }
 
@@ -1278,29 +1334,29 @@
 
 # ask for messages to new users
 sub message_default {
-    local($file) = $send_message;
-    local(@d) = ($file, $send_message_bak, "no");
+    local($file) = $config{send_message};
+    local(@d) = ($file, $config{send_message_bak}, "no");
 
-    while($verbose) {
+    while($config{verbose}) {
 	$file = &confirm_list("Send message from file:", 1, $file, @d);
 	last if $file eq "no";
 	last if &filetest($file, 1);
 
 	# maybe create message file
-	&message_create($file) if &confirm_yn("Create ``$file''?", "yes");
+	&message_create($file) if &confirm_yn("Create ``$file''?", "y");
 	last if &filetest($file, 0);
 	last if !&confirm_yn("File ``$file'' does not exist, try again?",
-			     "yes");
+			     "y");
     }
 
     if ($file eq "no" || !&filetest($file, 0)) {
-	warn "Do not send message\n" if $verbose;
+	warn "Do not send message\n" if $config{verbose};
 	$file = "no";
     } else {
 	&message_read($file);
     }
 
-    $changes++ if $file ne $send_message && $verbose;
+    $changes++ if $file ne $config{send_message} && $config{verbose};
     return $file;
 }
 
@@ -1312,7 +1368,7 @@
     if (!open(M, "> $file")) {
 	warn "Messagefile ``$file'': $!\n"; return 0;
     }
-    print M <<EOF;
+    print M <<"EOF";
 #
 # Message file for adduser(8)
 #   comment: ``#''
@@ -1334,16 +1390,11 @@
 
 # read message file into buffer
 sub message_read {
-    local($file) = @_;
-    @message_buffer = ();
-
-    if (!open(R, "$file")) {
-	warn "File ``$file'':$!\n"; return 0;
-    }
-    while(<R>) {
-	push(@message_buffer, $_) unless /^\s*#/;
-    }
-    close R;
+    my $file = shift;
+	open READ, "<$file" or warn "``$file'': $!\n\a" and return ();
+	my @message_buffer = grep { /^\s*/ ? () : $_ } <READ>;
+    close READ;
+	return @message_buffer;
 }
 
 # write @list to $file with file-locking
@@ -1352,14 +1403,14 @@
     local($e);
 
     open(F, ">> $file") || die "$file: $!\n";
-    print "Lock $file.\n" if $verbose > 1;
+    print "Lock $file.\n" if $config{verbose} > 1;
     while(!flock(F, LOCK_EX | LOCK_NB)) {
 	warn "Cannot lock file: $file\a\n";
 	die "Sorry, gave up\n"
-	    unless &confirm_yn("Try again?", "yes");
+	    unless &confirm_yn("Try again?", "y");
     }
     print F join("\n", @list) . "\n";
-    print "Unlock $file.\n" if $verbose > 1;
+    print "Unlock $file.\n" if $config{verbose} > 1;
     flock(F, LOCK_UN);
     close F;
 }
@@ -1369,62 +1420,95 @@
 sub next_id {
     local($group) = @_;
 
-    $uid_start = 1000 if ($uid_start <= 0 || $uid_start >= $uid_end);
+    $config{uid_start} = 1000 if ($config{uid_start} <= 0 || $config{uid_start} >= $uid_end);
     # looking for next free uid
-    while($uid{$uid_start}) {
-	$uid_start++;
-	$uid_start = 1000 if $uid_start >= $uid_end;
-	print "$uid_start\n" if $verbose > 1;
+    while($uid{ $config{uid_start} }) {
+	$config{uid_start}++;
+	$config{uid_start} = 1000 if $config{uid_start} >= $config{uid_end};
+	print $config{uid_start}."\n" if $config{verbose} > 1;
     }
 
-    local($gid_start) = $uid_start;
+    local($gid_start) = $config{uid_start};
     # group for user (username==groupname) already exist
-    if ($groupname{$group}) {
-	$gid_start = $groupname{$group};
+    if ($config{groupname} -> {$group}) {
+	$gid_start = $config{groupname} -> {$group};
     }
     # gid is in use, looking for another gid.
     # Note: uid and gid are not equal
-    elsif ($gid{$uid_start}) {
-	while($gid{$gid_start} || $uid{$gid_start}) {
+    elsif ($config{gid} -> { $config{uid_start} }) {
+	while($config{gid} -> {$gid_start} or $config{uid} -> {$gid_start}) {
 	    $gid_start--;
 	    $gid_start = $uid_end if $gid_start < 100;
 	}
     }
-    return ($uid_start, $gid_start);
+    return ($config{uid_start}, $gid_start);
 }
 
 # read config file - typically /etc/adduser.conf
-sub config_read {
+sub read_config {
     local($opt) = join " ", @_;
     local($user_flag) = 0;
 
     # don't read config file
-    return 1 if $opt =~ /-(noconfig|config_create)/ || !$config_read;
+    return 1 if $opt =~ /-(noconfig|config_create)/ || !$config{config_read};
 
     if (!-f $config) {
         warn("Couldn't find $config: creating a new adduser configuration file\n");
         &create_conf;
+		# since we set this to defaults we've got in this file, return.
+		return;
     }
 
-    if (!open(C, "$config")) {
-	warn "$config: $!\n"; return 0;
-    }
 
-    while(<C>) {
-	# user defined variables
-	/^$do_not_delete/ && $user_flag++;
-	# found @array or $variable
-	if (s/^(\w+\s*=\s*\()/\@$1/ || s/^(\w+\s*=)/\$$1/) {
-	    eval $_;
-	    #warn "$_";
-	}
-	next if /^$/;
-	# lines with '^##' are not saved
-	push(@user_variable_list, $_)
-	    if $user_flag && !/^##/ && (s/^[\$\@]// || /^[#\s]/);
-    }
-    #warn "X @user_variable_list X\n";
-    close C;
+
+	# we parse over the file looking for variables to interpolate. we
+	# do this within our Safe compartment so that we dont get users
+	# inserting $foo = `rm -rf /` into the file. perish the thought.
+	use Safe;
+	my $compartment = new Safe;
+	my ($this_line, @this_file);
+	$compartment -> permit(qw{ :default });
+	# $compartment -> share(qw{ $this_line });
+
+	open CONFIG, "<$config" or warn $! and return 0;
+	my @thisfile = <CONFIG>;
+	close CONFIG;
+    foreach $this_line (@thisfile) {
+
+		# user defined variables
+		$user_flag++ if $this_line =~ /^$do_not_delete/; 
+		
+		# if the first regex matches, we shouldnt see $$foo outputted. both
+		# millert and I am worried about this. -aja
+		if ($this_line =~ /^(\w+\s*=\s*\()/) {
+			# we have found an array.
+			$this_line =~ s/^/@/;
+			my $saferes = $compartment -> reval( $this_line );
+			if ($saferes ne $this_line and $saferes !~ /trapped/) {
+				# it was safe.
+				$this_line = $saferes;
+			}
+		}
+		elsif ($this_line =~ /^(\w+\s*=\s*[^(]+)/) {
+			# we have found a scalar
+			$this_line =~ s/^/\$/;
+			my $saferes = $compartment -> reval( $this_line );
+			if ($saferes ne $this_line and $saferes !~ /trapped/) {
+				# it was safe.
+				$this_line = $saferes;
+			}
+		}
+		# we skip ##'s as they are comments. more on this later.
+		next if $this_line =~ /^##/;
+
+		# here we check to see that we either started with a sigil [$@] 
+		# or we started with a comment or whitespace. we preserve the single
+		# '# blah' lines so that the file remains commented for the user.
+		if ($user_flag and 
+			(($this_line =~ s/^[$@]//) or ($this_line =~ /^(#\s|\s)/))) {
+			push @user_variable_list, $this_line;
+	    }
+	} # @thisfile
 }
 
 
@@ -1433,14 +1517,14 @@
     local($silent) = @_;
 
     # nothing to do
-    return 1 unless ($changes || ! -e $config || !$config_read || $silent);
+    return 1 unless ($changes || ! -e $config{configfile} || !$config_read || $silent);
 
     if (!$silent) {
 	if (-e $config) {
-	    return 1 if &confirm_yn("\nWrite your changes to $config?", "no");
+	    return 1 if &confirm_yn("\nWrite your changes to $config?", "n");
 	} else {
 	    return 1 unless
-		&confirm_yn("\nWrite your configuration to $config?", "yes");
+		&confirm_yn("\nWrite your configuration to $config?", "y");
 	}
     }
 
@@ -1448,64 +1532,64 @@
     open(C, "> $config") || die "$config: $!\n";
 
     # prepare some variables
-    $send_message = "no" unless $send_message;
-    $defaultpasswd = "no" unless $defaultpasswd;
-    local($shpref) = "'" . join("', '", @shellpref) . "'";
-    local($shpath) = "'" . join("', '", @path) . "'";
+    $config{send_message} = "no" unless $config{send_message};
+    $config{defaultpasswd} = "no" unless $config{defaultpasswd};
+    local($shpref) = "'" . join("', '", @{ $config{shellpref} }) . "'";
+    local($shpath) = "'" . join("', '", @{ $config{path} }) . "'";
     local($user_var) = join('', @user_variable_list);
 
-    print C <<EOF;
+    print C <<"EOF";
 #
 # $rcsid
-# $config - automatic generated by adduser(8)
+# $config{configfile} - automatic generated by adduser(8)
 #
 # Note: adduser reads *and* writes this file.
 #	You may change values, but don't add new things before the
 #	line ``$do_not_delete''
 #
 
-# verbose = [0-2]
-verbose = $verbose
+# verbose = (0 - 2)
+verbose = $config{verbose}
 
 # Get new password for new users
 # defaultpasswd =  yes | no
-defaultpasswd = $defaultpasswd
+defaultpasswd = $config{defaultpasswd}
 
 # Default encryption method for user passwords 
 # Methods are all those listed in passwd.conf(5)
 encryptionmethod = "$defaultencryption"
 
 # copy dotfiles from this dir ("/etc/skel" or "no")
-dotdir = "$dotdir"
+dotdir = "$config{dotdir}"
 
 # send this file to new user ("/etc/adduser.message" or "no")
-send_message = "$send_message"
+send_message = "$config{send_message}"
 
 # config file for adduser ("/etc/adduser.conf")
 config = "$config"
 
 # logfile ("/var/log/adduser" or "no")
-logfile = "$logfile"
+logfile = "$config{logfile}"
 
 # default HOME directory ("/home")
-home = "$home"
+home = "$config{home}"
 
 # List of directories where shells located
 # path = ('/bin', '/usr/bin', '/usr/local/bin')
 path = ($shpath)
 
 # common shell list, first element has higher priority
-# shellpref = ('bash', 'tcsh', 'ksh', 'csh', 'sh')
+# shellpref = ( 'csh', 'sh', 'tcsh', 'ksh', 'bash' )
 shellpref = ($shpref)
 
-# defaultshell if not empty ("bash")
-defaultshell = "$defaultshell"
+# defaultshell if not empty ("csh")
+defaultshell = "$config{defaultshell}"
 
 # defaultgroup ('USER' for same as username or any other valid group)
 defaultgroup = $defaultgroup
 
 # new users get this uid
-uid_start = $uid_start
+uid_start = $config{uid_start}
 uid_end = $uid_end
 
 $do_not_delete
@@ -1519,8 +1603,8 @@
 # check for sane variables
 sub variable_check {
 	# Check uid_start & uid_end
-	warn "WARNING: uid_start < 1000!\n" if($uid_start < 1000);
-	die "ERROR: uid_start >= uid_end!\n" if($uid_start >= $uid_end);
+	warn "WARNING: uid_start < 1000!\n" if($config{uid_start} < 1000);
+	die "ERROR: uid_start >= uid_end!\n" if($config{uid_start} >= $config{uid_end});
 	# unencrypted really only usable in batch mode
 	warn "WARNING: unencrypted only effective in batch mode\n"
 	    if($#batch < 0 && $unencrypted);
@@ -1535,8 +1619,12 @@
 }
 
 END {
-    if (-e $etc_ptmp && defined(fileno(PTMP))) {
-	    close PTMP;
-	    unlink($etc_ptmp) || warn "Error: unable to remove $etc_ptmp: $!\nPlease verify that $etc_ptmp no longer exists!\n";
-    }
+	if (-e $config{etc_ptmp} && defined(fileno(PTMP))) {
+		close PTMP;
+		unlink $config{etc_ptmp}
+			or warn << "WARNING";
+Error: unable to remove $config{etc_ptmp}: $!
+Please verify that $config{etc_ptmp} no longer exists.
+WARNING
+	}
 }
